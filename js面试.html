<!doctype html>
<html>
<head>
    <title>标题</title>
    <meta charset="utf-8">
    <style>

    </style>
</head>

<script>
    //判断是否为数组的3中方法;
    obj1 = {};
    obj2 = [];
    obj3 = obj2.__proto__;

    //1,

    console.log(
        obj3 instanceof Array,
        Object.getPrototypeOf(obj2) == Array.prototype
    );

    //2
    console.log(obj3.constructor === Array);

    //3
    console.log(
        Object.prototype.toString.call(obj3) == '[object Array]'
    )


    //闭包的题目


    //1、闭包和访问器属性
    'use strict';
    var eric={id:1001,ename:'Eric'};

    +function () {
        var _age;
        Object.defineProperty(eric,'age',{
            get:function () {
                return _age;
            },
            set:function (age) {
                if(age>=18&&age<=65){
                    _age=age;
                }else{
                    throw new RangeError("18-65");
                }
            }
        });
    }();
    eric.age=22; console.log(eric.age);
    eric._age=1; console.log(eric.age);


    //作用域链和原型链


    //继承

    //共用飞行方法
    function Fleyer(name, speed) {
        this.name = name;
        this.speed = speed;
    }

    //    原型函数
    Fleyer.prototype.fly = function () {
        console.log(
            this.name + "以时速" + this.speed + "飞行");
    };

    function Bee(name, speed, award) {
        //借用父类中构造函数的飞行方法，防止父类方法中的属性泄露;
        Fleyer.call(this, name, speed);
//        Fleyer.apply(this,arguments);
        this.award = award;
    }

    Bee.prototype.getAward = function () {
        console.log('击落' + this.name + '获得奖励' + this.award);
    };

    //   Bee.prototype=Fleyer.prototype;
    //    继承
    Object.setPrototypeOf(Bee.prototype, Fleyer.prototype);

    var bee1 = new Bee('bee1', 11, 100);
    console.dir(bee1);
    bee1.fly();
    bee1.getAward();


    //call 和apply
    //都是强行调用一个本来无法调用的函数，并且临时替换其中的this对象
    //    Fleyer.call(this,name,speed);
    //    Fleyer.apply(this,arguments);



    //一个方法合适定义在原型对象中何时定义在构造函数上

    //希望所有对象都能调用的方法;
    Array.isArray();
    //希望只有该类型的子对象才能够调用的方法
    var arr1=[];
    arr1.indexOf();

    //預解釋
    //预解释知解释等号左边的；
    //不管條件成不成立都會進行預結算
    //自自行函数不进行预解释，但是里面的私有变量和形参会进行预解释；
    console.log("num" in window);
    if(!("num" in window)){
        var num =12;
    }
    console.log(num);
    //当 变量已经存在，js不会进行重复定义
    function a(argument) {
        console.log(1);
    }
    a();
    
    var a=1;
    //作用域链：当前作用域下没有这个变量时，就往上级作用域去查找；
    //如何确定上级作用域：在哪个作用域下定义的就是谁！
    //作用域 
    function fn(n) {
        return function(i) {
            console.log(n+(i++));
        }
    }
    var f=fn(13);
    f(12);//25
    f(13);//27
    fn(14)(15);//29
    fn(15)(16);//31
    //作用域的销毁
    //1.闭包——函数 里 返回一个引用类型的数值（函数，对象，数组）并且由一个变量接收；

    function fn() {
        var num=1;
        return function ()() {
            
        }
    }
    var fn=fn();
    fn();

    //2.var odiv=#('#odiv'); div.click=function(){}

    //3.返回函数在执行 不会马上销毁；

     function fn() {
        var num=1;
        return function ()() {
            
        }
    }
    fn()();
</script>

<body>
</body>
</html>