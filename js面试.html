<!doctype html>
<html>
<head>
    <title>标题</title>
    <meta charset="utf-8">
    <style>

    </style>
</head>

<script>
    //判断是否为数组的3中方法;
    obj1 = {};
    obj2 = [];
    obj3 = obj2.__proto__;

    //1,

    console.log(
        obj3 instanceof Array,
        Object.getPrototypeOf(obj2) == Array.prototype
    );

    //2
    console.log(obj3.constructor === Array);

    //3
    console.log(
        Object.prototype.toString.call(obj3) == '[object Array]'
    )


    //闭包的题目


    //1、闭包和访问器属性
    'use strict';
    var eric={id:1001,ename:'Eric'};

    +function () {
        var _age;
        Object.defineProperty(eric,'age',{
            get:function () {
                return _age;
            },
            set:function (age) {
                if(age>=18&&age<=65){
                    _age=age;
                }else{
                    throw new RangeError("18-65");
                }
            }
        });
    }();
    eric.age=22; console.log(eric.age);
    eric._age=1; console.log(eric.age);


    //作用域链和原型链


    //继承

    //共用飞行方法
    function Fleyer(name, speed) {
        this.name = name;
        this.speed = speed;
    }

    //    原型函数
    Fleyer.prototype.fly = function () {
        console.log(
            this.name + "以时速" + this.speed + "飞行");
    };

    function Bee(name, speed, award) {
        //借用父类中构造函数的飞行方法，防止父类方法中的属性泄露;
        Fleyer.call(this, name, speed);
//        Fleyer.apply(this,arguments);
        this.award = award;
    }

    Bee.prototype.getAward = function () {
        console.log('击落' + this.name + '获得奖励' + this.award);
    };

    //   Bee.prototype=Fleyer.prototype;
    //    继承
    Object.setPrototypeOf(Bee.prototype, Fleyer.prototype);

    var bee1 = new Bee('bee1', 11, 100);
    console.dir(bee1);
    bee1.fly();
    bee1.getAward();


    //call 和apply
    //都是强行调用一个本来无法调用的函数，并且临时替换其中的this对象
    //    Fleyer.call(this,name,speed);
    //    Fleyer.apply(this,arguments);

</script>

<body>
</body>
</html>