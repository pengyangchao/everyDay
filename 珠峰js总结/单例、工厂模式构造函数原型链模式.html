<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script>
	//单例模式 : 主要解决了在统一作用域下对属性进行分组；
	//->person1或者person1叫做“命名空间”；
	var person1={
		name:'aaa'
	}
	var person1={
		name:'bbb'
	}

	//工厂模式：函数的封装，低耦合高内聚；

	//构造函数：目的是为了创建一个自定义类，并且创建这个类的实例；

	//->工厂模式,构造函数的区别？
	function createPerson(name,age) 
	{
		// var obj={};
		// obj.name=name;
		// obj.age=age;
		this.name=name;
		this.age=age;
		this.write=function(){
			console.log(this.name);
		}
		// return obj;
	}

	//1.执行的时候
	//var aaa=createPerson(aaa,18); 工厂模式
	//var bbb = new createPerson(bbb,18);构造函数 bbb就是createPerson类的一个实例

	//2.在函数执行代码的时候
	//相同：和普通函数一样，按照顺序执行，（形参定义-》预解释-》赋值）；
	//不同：不用自己去 var 一个对象 浏览器会自动帮我们生成一个对象数据类型的值（当前类的实例）并且进行赋值（属性名和属性值）；然后返回对象；

	//构造函数拓展
	//1.new createPerson()时没有参数，可以省略();
	//2.构造函数里面属性前我this一定指当前实例，函数里面的this就要看执行的时候'.'前面的是谁；
	var bbb = new createPerson('bbb',18)
	bbb.write(); //bbb
	var fn = bbb.write; fn(); //undefined;
	//3. return 一个引用数据类型的值会覆盖浏览器默认返回的对象;
	//4.检查一个实例是否属于这个类 instanceof
	//typeof 有局限性，不能区分数组和对象
	//5.in 判断属性是否属于这个对象；
	//hasOwnProperty是否为私有属性；
	console.log(bbb.hasOwnProperty('name')); 
	//判断属性是否为公用属性
	function hasPubProperty(obj,attr){
		return attr in obj && !obj.hasOwnProperty(attr);
	}
	var ret = hasPubProperty(bbb,'name');
	console.log(ret); //false

	//原型链
	//1.每个函数数据类型（函数、类）都有一个对象叫做protoype;
	//2.浏览器会给这个对象prototype添加一个属性construct（构造函数），值是这个函数或者类本身；
	//3.每个对象数据类型（实例、对象、prototype）也天生自带一个属性__proto__,属性值是当前实例所属类的原型（prototype）；

	// 链式写法的原理
	Array.prototype.myUnique=function (){
		var Obj = {};
		for(var i =0;i<this.length;i++){
			var cur = this[i];
			if(Obj[cur]==cur){
				this[i]=this[this.length-1];
				this.length--;
				i--;
				continue;
			}
			Obj[cur]=cur;
		}
		Obj=null;
		return this; //返回的是数组；
	}

	ary=[1,2,2,3,1,5,6,8,1,6,8];
	ary.myUnique().reverse();
	console.log(ary);
	ary.myUnique().pop().reverse();// ary.myUnique(...).pop(...).reverse is not a function  pop返回的不是数组；

	// 函数的三种角色
	//1.普通的函数，会有一个私有的作用域，（闭包） 形参的定义-》预解释-》赋值；
	//2.“类”， 会有prototype 。。。。。
	//3.普通的对象，就像Obj={}，会有__proto__指向Function.prototype;

</script>
</body>
</html>